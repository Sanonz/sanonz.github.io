<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sanonz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sanonz.github.io/"/>
  <updated>2018-02-24T11:03:09.000Z</updated>
  <id>https://sanonz.github.io/</id>
  
  <author>
    <name>Sanonz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Event Loop、Micro Task、Macro Task</title>
    <link href="https://sanonz.github.io/2018/javascript-event-loop-microtasks-macrotasks/"/>
    <id>https://sanonz.github.io/2018/javascript-event-loop-microtasks-macrotasks/</id>
    <published>2018-02-24T08:23:50.000Z</published>
    <updated>2018-02-24T11:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>Event Loop：事件循环、Micro Task：微任务、Macro Task：宏任务</p><p>我们知道 JavaScript 是单线程语言，一心不能二用，也就是说它只能把一件事干完才能去干另一件事，但前端的一些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让它们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以为了保证使用流畅，浏览器采用了 Event Loop 事件循环系统来管理，把那些耗时的任务放入 task queues 栈中，等主程序执行完再执行 task queues 中的任务，通常使用回调函数监听 task queues 中的任务状态。</p><p>在其它语言中可以迟延执行，比如 C 语言的 <code>sleep(3)</code> 可以迟延 3 秒执行后边的逻辑，但是在 JavaScript 中是没有这样的操作（除了 <code>alert</code>、<code>confrim</code>、<code>prompt</code> 和异步 <code>xhr</code>，官方说这些是历史遗留的错误设计😂），只能使用异步方式去模拟，模拟的实际也不是真正意义上的 <code>sleep</code> 效果。</p><a id="more"></a><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>在讨论 Micro Task、Macro Task 之前我们先来看一个例子，分析以下代码并思考 log 打的印顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>);</div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</div></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script start</div><div class="line">script end</div><div class="line">promise 1</div><div class="line">promise 2</div><div class="line">setTimeout 1</div></pre></td></tr></table></figure><p>有人可能会有疑问，为什么不是按顺序输出？又或者是这样<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script start</div><div class="line">script end</div><div class="line">setTimeout 1</div><div class="line">promise 1</div><div class="line">promise 2</div></pre></td></tr></table></figure><p></p><h3 id="Micro-Task、Macro-Task"><a href="#Micro-Task、Macro-Task" class="headerlink" title="Micro Task、Macro Task"></a>Micro Task、Macro Task</h3><p>想要搞明白这个问题，首先要了解 Event Loop 下的 <code>Micro Task</code> 和 <code>Macro Task</code>，在运行主程序时会把异步逻辑根据情况推到 <code>Micro Task</code> 或者 <code>Macro Task</code> 栈中，具体规则如下</p><p>以下情况会推到 <em>Micro Task</em> 栈中</p><ul><li>process.nextTick</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul><p>以下情况会推到 <em>Macro Task</em> 栈中</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI render</li></ul><p>然后再来看实例代码的实际执行逻辑</p><ol><li>执行 <code>console.log(&#39;script start&#39;)</code> 直接输出</li><li>执行 <code>setTimeout</code> 把回调函数放入 <em>Macro Task</em> 栈中</li><li>执行 <code>Promise</code> 把两个 then 的回调函数放入 <em>Micro Task</em> 栈中</li><li>执行 <code>console.log(&#39;script end&#39;)</code> 直接输出</li><li>执行 <em>Micro Task</em> 中所有任务<ol><li>执行 <code>console.log(&#39;promise 1&#39;)</code> 直接输出</li><li>执行 <code>console.log(&#39;promise 2&#39;)</code> 直接输出</li></ol></li><li>执行 <em>Macro Task</em> 中所有任务<ol><li>执行 <code>console.log(&#39;setTimeout 1&#39;)</code> 直接输出</li></ol></li></ol><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script (整体代码) 开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 Micro Task。当所有可执行的 Micro Task 执行完毕之后。循环再次从 Macro Task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 Micro Task，在执行 Micro Task、Macro Task 的时候同样遵循 Event Loop 原则，就这样一直循环下去。</p><p>至此结束，感谢阅读。<br><br></p><h5 id="参考站点"><a href="#参考站点" class="headerlink" title="参考站点"></a>参考站点</h5><ul><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/webappapis.html#event-loop</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h3&gt;&lt;p&gt;Event Loop：事件循环、Micro Task：微任务、Macro Task：宏任务&lt;/p&gt;&lt;p&gt;我们知道 JavaScript 是单线程语言，一心不能二用，也就是说它只能把一件事干完才能去干另一件事，但前端的一些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让它们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以为了保证使用流畅，浏览器采用了 Event Loop 事件循环系统来管理，把那些耗时的任务放入 task queues 栈中，等主程序执行完再执行 task queues 中的任务，通常使用回调函数监听 task queues 中的任务状态。&lt;/p&gt;&lt;p&gt;在其它语言中可以迟延执行，比如 C 语言的 &lt;code&gt;sleep(3)&lt;/code&gt; 可以迟延 3 秒执行后边的逻辑，但是在 JavaScript 中是没有这样的操作（除了 &lt;code&gt;alert&lt;/code&gt;、&lt;code&gt;confrim&lt;/code&gt;、&lt;code&gt;prompt&lt;/code&gt; 和异步 &lt;code&gt;xhr&lt;/code&gt;，官方说这些是历史遗留的错误设计😂），只能使用异步方式去模拟，模拟的实际也不是真正意义上的 &lt;code&gt;sleep&lt;/code&gt; 效果。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://sanonz.github.io/categories/front-end/"/>
    
    
      <category term="JavaScript" scheme="https://sanonz.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly 从入门到吃鸡</title>
    <link href="https://sanonz.github.io/2018/webassembly-tutorial/"/>
    <id>https://sanonz.github.io/2018/webassembly-tutorial/</id>
    <published>2018-01-12T06:58:00.000Z</published>
    <updated>2018-01-17T11:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WebAssembly-介绍"><a href="#WebAssembly-介绍" class="headerlink" title="WebAssembly 介绍"></a>WebAssembly 介绍</h3><p>我们知道 JavaScript 是一门脚本语言，具有动态类型和灵活的表达力，我们知道脚本语言通常要解释运行，这也将要消耗一些性能开销，于是 Google 在 2009 年在 V8 中引入了 JIT(Just in time compiling) 技术，把 JavaScript 运行时的性能推到了顶峰，同年利用 V8 引擎诞生了 Node.js，打开了使用 JavaScript 写后端应用的大门。对于目前写网络应用而言 JavaScript 已经足够用了，加上 Google V8 引擎能帮我们解决掉大部分问题。但是当我们把 JavaScript 应用到诸如 3D 游戏、虚拟现实、增强现实、计算机视觉、图像/视频编辑以及大量的要求原生性能的其他领域的时候，就遇到了性能问题，尤其是移动平台进一步放大了这些性能瓶颈。</p><p>而 WebAssembly 的出现就是为了解决这个问题，它是一门低级的类汇编语言，可以运行在现代网络浏览器中的新型代码并且提供新的性能特性和效果。它设计的目的不是为了手写代码，而是为了诸如 C、C++ 和 Rust 等低级源语言提供一个高效的编译目标以便它们能够在网络上运行。对于网络平台而言，这具有巨大的意义——这为客户端 app 提供了一种在网络平台以接近本地速度的方式运行多种语言编写代码的方式；在这之前，客户端 app 是不可能做到的。</p><a id="more"></a><h3 id="WebAssembly-使用"><a href="#WebAssembly-使用" class="headerlink" title="WebAssembly 使用"></a>WebAssembly 使用</h3><p>WebAssembly 有二进制 (.wasm) 和文本 (.wast) 两种格式，并且两种格式可以互享转换，在传输和运行时使用二进制格式，而文本格式是为了阅读和开发调试所使用。</p><p>以 C 为例，首先把 C 程序编译为 WebAssembly 格式，本地编译可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/C_to_wasm" target="_blank" rel="noopener">编译 C/C++ 为 WebAssembly</a> 文章进行相关软件的安装，为了方便可以直接使用这款在线工具进行转换 <a href="https://wasdk.github.io/WasmFiddle/" target="_blank" rel="noopener">WasmFiddle</a></p><p>我们先来个简单的，在 <code>main</code> 中返回一个数字，在 <code>add</code> 方法中求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </div><div class="line">  <span class="keyword">return</span> <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>转换过后的 .wast 文本格式为，我们可以从这个文本看出分别 export 了 <code>main</code> 与 <code>add</code> 方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(module</div><div class="line"> (table 0 anyfunc)</div><div class="line"> (memory $0 1)</div><div class="line"> (export "memory" (memory $0))</div><div class="line"> (export "main" (func $main))</div><div class="line"> (export "add" (func $add))</div><div class="line"> (func $main (; 0 ;) (result i32)</div><div class="line">  (i32.const 42)</div><div class="line"> )</div><div class="line"> (func $add (; 1 ;) (param $0 i32) (param $1 i32) (result i32)</div><div class="line">  (i32.add</div><div class="line">   (get_local $1)</div><div class="line">   (get_local $0)</div><div class="line">  )</div><div class="line"> )</div><div class="line">)</div></pre></td></tr></table></figure><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch</a> 获取模块并初始化调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'module.wasm'</span>)</div><div class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.arrayBuffer())</div><div class="line">  .then(<span class="function"><span class="params">bytes</span> =&gt;</span> WebAssembly.instantiate(bytes))</div><div class="line">  .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> results.instance.exports.main); <span class="comment">// function</span></div><div class="line">    <span class="built_in">console</span>.log(results.instance.exports.main()); <span class="comment">// 42</span></div><div class="line">    <span class="built_in">console</span>.log(results.instance.exports.add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>我们可以使用 <code>results.instance.exports.main()</code> 的形式进行调用</p><p>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a> 获取模块并初始化调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">request.open(<span class="string">'GET'</span>, <span class="string">'module.wasm'</span>);</div><div class="line">request.responseType = <span class="string">'arraybuffer'</span>;</div><div class="line"></div><div class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bytes = request.response;</div><div class="line">  WebAssembly</div><div class="line">  .instantiate(bytes)</div><div class="line">  .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</div><div class="line">    results.instance.exports.main();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.send();</div></pre></td></tr></table></figure><p>目前只实现了 JavaScript 语言调用 C 语言，接下来使用 C 调用 JavaScript 方法，声明并在需要的地方调用 <code>alert</code> 方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">alert</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> alert(a + b);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取实例时传入 <code>importObj</code> 对象，把 <code>env</code> 环境变量注入进来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> importObj = &#123;</div><div class="line">  env: &#123;</div><div class="line">    alert: <span class="built_in">window</span>.alert</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">fetch(<span class="string">'module.wasm'</span>)</div><div class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.arrayBuffer())</div><div class="line">  .then(<span class="function"><span class="params">bytes</span> =&gt;</span> WebAssembly.instantiate(bytes, importObj))</div><div class="line">  .then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(results.instance.exports.add(<span class="number">1</span>, <span class="number">2</span>));</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>至此相互调用演示完成，我们可以畅想下以后 WebAssembly 普及的话，到时我们用的 React、Vue、Angular 可能就是用 C/C++ 或者其他底层语言写的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;WebAssembly-介绍&quot;&gt;&lt;a href=&quot;#WebAssembly-介绍&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly 介绍&quot;&gt;&lt;/a&gt;WebAssembly 介绍&lt;/h3&gt;&lt;p&gt;我们知道 JavaScript 是一门脚本语言，具有动态类型和灵活的表达力，我们知道脚本语言通常要解释运行，这也将要消耗一些性能开销，于是 Google 在 2009 年在 V8 中引入了 JIT(Just in time compiling) 技术，把 JavaScript 运行时的性能推到了顶峰，同年利用 V8 引擎诞生了 Node.js，打开了使用 JavaScript 写后端应用的大门。对于目前写网络应用而言 JavaScript 已经足够用了，加上 Google V8 引擎能帮我们解决掉大部分问题。但是当我们把 JavaScript 应用到诸如 3D 游戏、虚拟现实、增强现实、计算机视觉、图像/视频编辑以及大量的要求原生性能的其他领域的时候，就遇到了性能问题，尤其是移动平台进一步放大了这些性能瓶颈。&lt;/p&gt;&lt;p&gt;而 WebAssembly 的出现就是为了解决这个问题，它是一门低级的类汇编语言，可以运行在现代网络浏览器中的新型代码并且提供新的性能特性和效果。它设计的目的不是为了手写代码，而是为了诸如 C、C++ 和 Rust 等低级源语言提供一个高效的编译目标以便它们能够在网络上运行。对于网络平台而言，这具有巨大的意义——这为客户端 app 提供了一种在网络平台以接近本地速度的方式运行多种语言编写代码的方式；在这之前，客户端 app 是不可能做到的。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://sanonz.github.io/categories/front-end/"/>
    
    
      <category term="JavaScript" scheme="https://sanonz.github.io/tags/JavaScript/"/>
    
      <category term="WebAssembly" scheme="https://sanonz.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt 使用教程，免费的 SSL 证书，让你的网站拥抱 HTTPS</title>
    <link href="https://sanonz.github.io/2017/let&#39;s-encrypt-free-ssl-https/"/>
    <id>https://sanonz.github.io/2017/let&#39;s-encrypt-free-ssl-https/</id>
    <published>2017-11-15T07:45:47.000Z</published>
    <updated>2017-11-27T08:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Let’s-Encrypt-简介"><a href="#Let’s-Encrypt-简介" class="headerlink" title="Let’s Encrypt 简介"></a>Let’s Encrypt 简介</h3><p>Let’s Encrypt 是国外一个公共的免费SSL项目，由 Linux 基金会托管，它的来头不小，由 Mozilla、思科、Akamai、IdenTrust 和 EFF 等组织发起，目的就是向网站自动签发和管理免费证书，以便加速互联网由 HTTP 过渡到 HTTPS，目前 Facebook 等大公司开始加入赞助行列。</p><p>Let’s Encrypt 已经得了 IdenTrust 的交叉签名，这意味着其证书现在已经可以被 Mozilla、Google、Microsoft 和 Apple 等主流的浏览器所信任，你只需要在 Web 服务器证书链中配置交叉签名，浏览器客户端会自动处理好其它的一切，Let’s Encrypt 安装简单，使用非常方便。</p><h3 id="Certbot-简介"><a href="#Certbot-简介" class="headerlink" title="Certbot 简介"></a>Certbot 简介</h3><p><a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a> 为 Let’s Encrypt 项目发布了一个官方的客户端 Certbot ，利用它可以完全自动化的获取、部署和更新安全证书，并且 Certbot 是支持所有 Unix 内核的操作系统。</p><a id="more"></a><h3 id="安装-Certbot-客户端"><a href="#安装-Certbot-客户端" class="headerlink" title="安装 Certbot 客户端"></a>安装 Certbot 客户端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> yum install certbot <span class="comment"># centos</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># apt install certbot # ubuntu</span></span></div></pre></td></tr></table></figure><h3 id="Certbot-的两种使用方式"><a href="#Certbot-的两种使用方式" class="headerlink" title="Certbot 的两种使用方式"></a>Certbot 的两种使用方式</h3><ol><li><em>webroot</em> 方式： certbot 会利用既有的 web server，在其 web root 目录下创建隐藏文件，Let’s Encrypt 服务端会通过域名来访问这些隐藏文件，以确认你的确拥有对应域名的控制权。</li><li><em>standalone</em> 方式： Certbot 会自己运行一个 web server 来进行验证。如果我们自己的服务器上已经有 web server 正在运行 （比如 Nginx 或 Apache ），用 standalone 方式的话需要先关掉它，以免冲突。</li></ol><h3 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h3><h4 id="webroot-模式"><a href="#webroot-模式" class="headerlink" title="webroot 模式"></a>webroot 模式</h4><p>使用这种模式会在 web root 中创建 .well-known 文件夹，这个文件夹里面包含了一些验证文件，Certbot 会通过访问 example.com/.well-known/acme-challenge 来验证你的域名是否绑定的这个服务器，所以需要编辑 nginx 配置文件确保可以访问刚刚创建的 .well-known 文件夹及里边存放的验证文件，以便在生成证书时进行验证：</p><p>使用一下命令查看 nginx 配置文件地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo nginx -t</span></div><div class="line">nginx: the configuration file /usr/local/nginx/nginx.conf syntax is ok</div><div class="line">nginx: configuration file /usr/local/nginx/nginx.conf test is successful</div></pre></td></tr></table></figure><p>编辑 /usr/local/nginx/nginx.conf 配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    location /.well-known/acme-challenge/ &#123;</div><div class="line">        default_type "text/plain";</div><div class="line">        root /var/www/example;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重启 nginx 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nginx -s reload</span></div></pre></td></tr></table></figure><p>获取证书，<code>--email</code> 为申请者邮箱，<code>--webroot</code> 为 webroot 方式，<code>-w</code> 为站点目录，<code>-d</code> 为要加 https 的域名，以下命令会为 example.com 和 www.example.com 这两个域名生成一个证书：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> certbot certonly --email admin@example.com --webroot -w /var/www/example -d example.com -d www.example.com</span></div></pre></td></tr></table></figure><h4 id="standalone-模式获取证书"><a href="#standalone-模式获取证书" class="headerlink" title="standalone 模式获取证书"></a>standalone 模式获取证书</h4><p>但是有些时候我们的一些服务并没有根目录，例如一些微服务，这时候使用 webroot 模式就走不通了。这时可以使用模式 standalone 模式，这种模式不需要指定网站根目录，他会自动启用服务器的443端口，来验证域名的归属。我们有其他服务（例如nginx）占用了443端口，就必须先停止这些服务，在证书生成完毕后，再启用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> certbot certonly --email admin@example.com --standalone -d example.com -d www.example.com</span></div></pre></td></tr></table></figure><h3 id="nginx-开启-https"><a href="#nginx-开启-https" class="headerlink" title="nginx 开启 https"></a>nginx 开启 https</h3><p>证书生成完成后可以到 /etc/letsencrypt/live/ 目录下查看对应域名的证书文件。编辑 nginx 配置文件监听 443 端口，启用 SSL，并配置 SSL 的公钥、私钥证书路径：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line"></div><div class="line">    <span class="attribute">listen</span>       <span class="number">443</span>;</div><div class="line">    <span class="attribute">server_name</span>  example.com;</div><div class="line">    <span class="attribute">root</span>         /var/www/example;</div><div class="line">    <span class="attribute">index</span>        index.html index.htm;</div><div class="line"></div><div class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.com/fullchain.pem;</div><div class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.com/privkey.pem;</div><div class="line"></div><div class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>添加 HTTP 跳转到 HTTPS：<br></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span> example.com;</div><div class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>重启 nginx 服务，访问 <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> 查看是否配置成功</p><h3 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h3><p>Let’s Encrypt 提供的证书只有90天的有效期，所以我们要在在证书到期之前重新获取这些证书，Certbot 提供了一个方便的命令 <code>certbot renew</code>，我们可以先使用 <code>--dry-run</code> 测试是否可用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> certbot renew --dry-run</span></div></pre></td></tr></table></figure><p>linux 系统上有 cron 可以来搞定这件事情，使用一下命令新建任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> crontab -e</span></div></pre></td></tr></table></figure><p>写入一下任务内容。这段内容的意思就是 每隔 两个月的 凌晨 2:15 执行 更新操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">15 2 * */2 * certbot renew --quiet --renew-hook <span class="string">"service nginx restart"</span></div></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>–quiet</td><td>执行时屏蔽错误以外的所有输出，也可以使用 -q</td></tr><tr><td>–pre-hook</td><td>执行更新操作之前要做的事情</td></tr><tr><td>–pre-hook</td><td>执行更新操作之前要做的事情</td></tr><tr><td>–post-hook</td><td>执行更新操作完成后要做的事情</td></tr></tbody></table><h3 id="取消证书"><a href="#取消证书" class="headerlink" title="取消证书"></a>取消证书</h3><p>可以使用一下命令取消刚刚生成的密匙，也就是以上的反操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> certbot revoke --cert-path /etc/letsencrypt/live/example.com/cert.pem</span></div><div class="line"><span class="meta">$</span><span class="bash"> certbot delete --cert-name example.com</span></div></pre></td></tr></table></figure><p>至此，整个网站升级到 HTTPS 就完成了。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><ol><li>如果加上 HTTPS 之后😊锁不够绿的话，检查下站点加载的资源（比如 js、css、照片等）是不是有 HTTP 的，有的话就会导致小锁变为灰色。</li><li>在我们使用 HTTP 的时候，打开网页总会遇到第三方偷偷加的一些脚本广告，很是烦人，升级 HTTPS 后他们就无从下手了，欧耶。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Let’s-Encrypt-简介&quot;&gt;&lt;a href=&quot;#Let’s-Encrypt-简介&quot; class=&quot;headerlink&quot; title=&quot;Let’s Encrypt 简介&quot;&gt;&lt;/a&gt;Let’s Encrypt 简介&lt;/h3&gt;&lt;p&gt;Let’s Encrypt 是国外一个公共的免费SSL项目，由 Linux 基金会托管，它的来头不小，由 Mozilla、思科、Akamai、IdenTrust 和 EFF 等组织发起，目的就是向网站自动签发和管理免费证书，以便加速互联网由 HTTP 过渡到 HTTPS，目前 Facebook 等大公司开始加入赞助行列。&lt;/p&gt;&lt;p&gt;Let’s Encrypt 已经得了 IdenTrust 的交叉签名，这意味着其证书现在已经可以被 Mozilla、Google、Microsoft 和 Apple 等主流的浏览器所信任，你只需要在 Web 服务器证书链中配置交叉签名，浏览器客户端会自动处理好其它的一切，Let’s Encrypt 安装简单，使用非常方便。&lt;/p&gt;&lt;h3 id=&quot;Certbot-简介&quot;&gt;&lt;a href=&quot;#Certbot-简介&quot; class=&quot;headerlink&quot; title=&quot;Certbot 简介&quot;&gt;&lt;/a&gt;Certbot 简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://certbot.eff.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Certbot&lt;/a&gt; 为 Let’s Encrypt 项目发布了一个官方的客户端 Certbot ，利用它可以完全自动化的获取、部署和更新安全证书，并且 Certbot 是支持所有 Unix 内核的操作系统。&lt;/p&gt;
    
    </summary>
    
      <category term="back-end" scheme="https://sanonz.github.io/categories/back-end/"/>
    
    
      <category term="Http" scheme="https://sanonz.github.io/tags/Http/"/>
    
      <category term="Centos" scheme="https://sanonz.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 搭建 php、mysql、nginx 开发环境</title>
    <link href="https://sanonz.github.io/2017/ubuntu-install-nginx-php-mysql/"/>
    <id>https://sanonz.github.io/2017/ubuntu-install-nginx-php-mysql/</id>
    <published>2017-11-14T03:26:20.000Z</published>
    <updated>2017-11-28T01:53:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="php-安装"><a href="#php-安装" class="headerlink" title="php 安装"></a>php 安装</h3><p>进入 php 官方站点现在所需版本 <a href="http://php.net/downloads.php" target="_blank" rel="noopener">http://php.net/downloads.php</a>，提取下载地址使用 <code>wget</code> 进行下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</div><div class="line">$ wget http://cn.php.net/distributions/php-7.1.11.tar.gz</div></pre></td></tr></table></figure><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar zxf php-7.1.11.tar.gz php-7.1.11-src</div><div class="line">$ <span class="built_in">cd</span> ./php-7.1.11-src</div></pre></td></tr></table></figure><p>安装依赖库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install make build-essential libxml2-dev</div></pre></td></tr></table></figure><a id="more"></a><p>具体的配置选项列表使用 <code>./configure --help</code> 或者查看官方文档 <a href="http://php.net/manual/zh/configure.about.php" target="_blank" rel="noopener">http://php.net/manual/zh/configure.about.php</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ ./configure \</div><div class="line">--prefix=/usr/<span class="built_in">local</span>/php-7.1.11 \</div><div class="line">--with-curl \</div><div class="line">--with-zlib \</div><div class="line">--with-iconv \</div><div class="line">--with-xmlrpc \</div><div class="line">--with-openssl \</div><div class="line">--with-pcre-jit \</div><div class="line">--with-pdo-mysql=shared,mysqlnd \</div><div class="line">--without-pear \</div><div class="line">--<span class="built_in">enable</span>-xml \</div><div class="line">--<span class="built_in">enable</span>-fpm \</div><div class="line">--<span class="built_in">disable</span>-dom \</div><div class="line">--<span class="built_in">enable</span>-shared \</div><div class="line">--<span class="built_in">enable</span>-sockets \</div><div class="line">--<span class="built_in">enable</span>-mbstring \</div><div class="line">--<span class="built_in">disable</span>-rpath \</div><div class="line">--<span class="built_in">disable</span>-fileinfo</div></pre></td></tr></table></figure><p>如果提示 <code>Cannot find OpenSSL&#39;s &lt;evp.h&gt;</code> 执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install libssl-dev</div></pre></td></tr></table></figure><p>如果提示 <code>Cannot find OpenSSL&#39;s libraries</code> 执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ find / -name libssl.so</div><div class="line">/usr/lib/x86_64-linux-gnu/libssl.so</div><div class="line">$ ln -s /usr/lib/x86_64-linux-gnu/libssl.so /usr/lib</div></pre></td></tr></table></figure><p>创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp ./lib/php.ini-development ./lib/php.ini</div><div class="line">$ cp ./etc/php-fpm.conf.default ./etc/php-fpm.conf</div></pre></td></tr></table></figure><h3 id="mysql-安装"><a href="#mysql-安装" class="headerlink" title="mysql 安装"></a>mysql 安装</h3><p>安装前可以使用以下命令查看当前的 mysql 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ apt show mysql-server</div><div class="line">Package: mysql-server</div><div class="line">Version: 5.7.20-0ubuntu0.16.04.1</div><div class="line">Priority: optional</div><div class="line">Section: database</div><div class="line">Source: mysql-5.7</div><div class="line">...</div></pre></td></tr></table></figure><p>执行以下命令安装 mysql：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install mysql-server</div></pre></td></tr></table></figure><p>安装过程中需要输入密码：</p><img src="/2017/ubuntu-install-nginx-php-mysql/mysql-install-new-password.png"><p>然后在重复输入密码：</p><img src="/2017/ubuntu-install-nginx-php-mysql/mysql-install-repeat-password.png"><p>设置完成后等待自动安装即可，安装完成 mysql 默认就启动了，可以执行以下命令查看，只要看到出来一坨代码就说明已经启动成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps -ef | grep mysqld</div></pre></td></tr></table></figure><p>可以使用以下命令控制 mysql 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ service mysql stop</div><div class="line">$ service mysql start</div><div class="line">$ service mysql restart</div></pre></td></tr></table></figure><p>使用以下命令进入 mysql shell 界面，按提示输入密码，可以使用 <code>show databases</code> 查看数据库列表，用 <code>exit</code> 命令退出 shell 界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ mysql -uroot -p</div><div class="line">Enter password:</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 7</div><div class="line">Server version: 5.7.20-0ubuntu0.16.04.1 (Ubuntu)</div><div class="line"></div><div class="line">Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</div><div class="line"></div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line"></div><div class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</div><div class="line"></div><div class="line">mysql&gt; show databases;</div><div class="line">+--------------------+</div><div class="line">| Database           |</div><div class="line">+--------------------+</div><div class="line">| information_schema |</div><div class="line">| mysql              |</div><div class="line">| performance_schema |</div><div class="line">| sys                |</div><div class="line">+--------------------+</div><div class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.02 sec)</div><div class="line"></div><div class="line">mysql&gt; <span class="built_in">exit</span>;</div><div class="line">Bye</div></pre></td></tr></table></figure><h3 id="nginx-安装"><a href="#nginx-安装" class="headerlink" title="nginx 安装"></a>nginx 安装</h3><p>执行以下命令安装 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt install nginx</div></pre></td></tr></table></figure><p>先启动 nginx，然后访问 ip 查看是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service nginx start</div></pre></td></tr></table></figure><p>编辑 nginx 配置文件，添加 php 解析</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</div><div class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</div><div class="line">        <span class="attribute">fastcgi_index</span>  index.php;</div><div class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</div><div class="line">        <span class="attribute">include</span>        fastcgi_params;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>新建 php 文件并访问</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">phpinfo();</div></pre></td></tr></table></figure><p>完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;php-安装&quot;&gt;&lt;a href=&quot;#php-安装&quot; class=&quot;headerlink&quot; title=&quot;php 安装&quot;&gt;&lt;/a&gt;php 安装&lt;/h3&gt;&lt;p&gt;进入 php 官方站点现在所需版本 &lt;a href=&quot;http://php.net/downloads.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://php.net/downloads.php&lt;/a&gt;，提取下载地址使用 &lt;code&gt;wget&lt;/code&gt; 进行下载：&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ wget http://cn.php.net/distributions/php-7.1.11.tar.gz&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;解压文件&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar zxf php-7.1.11.tar.gz php-7.1.11-src&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ./php-7.1.11-src&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装依赖库&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ apt install make build-essential libxml2-dev&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="back-end" scheme="https://sanonz.github.io/categories/back-end/"/>
    
    
      <category term="php" scheme="https://sanonz.github.io/tags/php/"/>
    
      <category term="mysql" scheme="https://sanonz.github.io/tags/mysql/"/>
    
      <category term="nginx" scheme="https://sanonz.github.io/tags/nginx/"/>
    
      <category term="ubuntu" scheme="https://sanonz.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 三维教程 - 绘制矩形和点（二）</title>
    <link href="https://sanonz.github.io/2017/webgl-draw-rectangle-and-point/"/>
    <id>https://sanonz.github.io/2017/webgl-draw-rectangle-and-point/</id>
    <published>2017-11-03T11:29:20.000Z</published>
    <updated>2018-01-17T11:54:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Canvas-简介"><a href="#Canvas-简介" class="headerlink" title="Canvas 简介"></a>Canvas 简介</h3><p>在 HTML5 出现之前，如果想要在网页上显示图像，只能使用 HTML 提供的 <code>&lt;img&gt;</code> 标签。用这个标签虽然简单，但是只能显示静态的图片，不能进行实时绘制和渲染，所以后来出现了一些第三方的解决方案，比如 Flash Player 等。</p><p>Canvas 中文译为“画布”，作为画布我们可以使用 <code>HTMLCanvasElement.getContext(contextType)</code> 获取 Canvas 的上下文，然后使用上下文提供的 API 在画布区域绘制图案，接下来分别介绍怎么使用二维和三维的方法绘制矩形和点。</p><a id="more"></a><p>contextType 的取值如下：</p><ol><li><code>&quot;2d&quot;</code> 建立一个 <code>CanvasRenderingContext2D</code> 对象，代表一个二维渲染上下文。</li><li><code>&quot;webgl&quot;</code> 或 <code>&quot;experimental-webgl&quot;</code> 这将创建一个 <code>WebGLRenderingContext</code> 代表三维渲染上下文对象 (OpenGL ES 2.0)。</li></ol><h3 id="二维绘制矩形"><a href="#二维绘制矩形" class="headerlink" title="二维绘制矩形"></a>二维绘制矩形</h3><p>首先要写一个 canvas 元素，然后获取二维渲染的上下文：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"gl"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure><p>绘制二维矩形很简单，只需要调用上下文的 <code>ctx.fillRect(x, y, width, height)</code> 方法即可，语法如下：</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>x</td><td>矩形起始点的 x 轴坐标</td></tr><tr><td>y</td><td>矩形起始点的 y 轴坐标</td></tr><tr><td>width</td><td>矩形的宽度</td></tr><tr><td>height</td><td>矩形的高度</td></tr></tbody></table><p>在调用之前首先使用 <code>ctx.fillStyle</code> 设置要填充的颜色，这里我们填充的是蓝色，具体绘制矩形的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'2d'</span>);</div><div class="line">ctx.fillStyle = <span class="string">'rgba(0, 0, 255, 1.0)'</span>;</div><div class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</div></pre></td></tr></table></figure><p>运行效果为一个蓝色的矩形 <a href="https://stackblitz.com/edit/canvas-draw-rectangle" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-rectangle-blue@2x.png" width="320" height="316"><h3 id="三维绘制矩形"><a href="#三维绘制矩形" class="headerlink" title="三维绘制矩形"></a>三维绘制矩形</h3><p>和二维绘制矩形一样，在三维绘制一个矩形也是很简单的，首先要获取 <code>WebGLRenderingContext</code> 的对象，其次是调用 <code>gl.clearColor(red, green, blue, alpha)</code> 设置背景色，语法如下：</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>red</td><td>指定清除缓冲时的红色值。默认值：0</td></tr><tr><td>green</td><td>指定清除缓冲时的绿色值。默认值：0</td></tr><tr><td>blue</td><td>指定清除缓冲时的蓝色值。默认值：0</td></tr><tr><td>alpha</td><td>指定清除缓冲时的不透明度。默认值：0</td></tr></tbody></table><p>下面列出的是一些常用的颜色：</p><table><thead><tr><th>色值</th><th>描述</th></tr></thead><tbody><tr><td>(1.0, 0.0, 0.0, 1.0)</td><td>红色</td></tr><tr><td>(0.0, 1.0, 0.0, 1.0)</td><td>绿色</td></tr><tr><td>(0.0, 0.0, 1.0, 1.0)</td><td>蓝色</td></tr><tr><td>(1.0, 1.0, 0.0, 1.0)</td><td>黄色</td></tr><tr><td>(1.0, 0.0, 1.0, 1.0)</td><td>紫色</td></tr><tr><td>(0.0, 1.0, 1.0, 1.0)</td><td>青色</td></tr><tr><td>(1.0, 1.0, 1.0, 1.0)</td><td>白色</td></tr></tbody></table><p>然后在调用 <code>gl.clear(mask)</code> 用背景色清空 canvas 绘图区域，<code>mask</code> 参数为指定待清空的缓冲区，可以使用位操作符 <code>OR(|)</code> 来指定多个缓冲区，可以取的常量如下：</p><table><thead><tr><th>常量</th><th>表述</th></tr></thead><tbody><tr><td>gl.COLOR_BUFFER_BIT</td><td>指定颜色缓冲区</td></tr><tr><td>gl.DEPTH_BUFFER_BIT</td><td>指定深度缓冲区</td></tr><tr><td>gl.STENCIL_BUFFER_BIT</td><td>指定模版缓冲区</td></tr></tbody></table><p>这里我们设置的背景色为黑色，最后的代码如下，运行后我们想要的矩形就出来了，这个也是最短的 WebGL 程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">gl.clear(<span class="keyword">this</span>.gl.COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure><p>运行效果为一个黑色矩形 <a href="https://stackblitz.com/edit/webgl-draw-rectangle" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-rectangle-black@2x.png" width="318" height="318"><h3 id="三维绘制点"><a href="#三维绘制点" class="headerlink" title="三维绘制点"></a>三维绘制点</h3><p>前边我们分别使用三行代码分别绘制了二维与三维的矩形，我们知道，在二维世界坐标是 <code>(x, y)</code>，在三维世界比二维多了一个 <code>z</code> （深度），坐标也就是 <code>(x, y, z)</code>，然后推测根据二维的代码多加一个 <code>z</code> 坐标应该就能画三维中的矩形，修改代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">gl.drawColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">gl.drawPoint(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 点的位置和大小</span></div></pre></td></tr></table></figure><p>然而事情并没有那么简单，当我们运行代码发现出错了，实际的三维绘图要比二维复杂的多，WebGL 依赖于一种新的称为 <em>着色器</em> (shader) 的绘图机制，上一篇 <a href="/2017/webgl-introduction/" title="WebGL 三维教程 - WebGL 介绍（一）">WebGL 三维教程 - WebGL 介绍（一）</a> 我们简单介绍了 WebGL，其中有提及到 GLSL (OpenGL Shading Language)，那么 GLSL 到底是什么呢？GLSL 为着色语言，用来编写 shader 脚本，着色器分为 <em>顶点着色器</em> (Vertex shader) 与 <em>片元着色器</em> (Fragment shader) 两部分，着色器提供了灵活而强大的绘制二维或三维图形的方法，正是因为它的强大，因此也带来了使用上的复杂度，接下来的教程中，我们将一步步去深入研究和理解它。</p><h4 id="三维世界的坐标系统"><a href="#三维世界的坐标系统" class="headerlink" title="三维世界的坐标系统"></a>三维世界的坐标系统</h4><p>WebGL 中的坐标是由 (x, y, z) 组成，下图描述了 WebGL 坐标系。z 轴表示深度，正值 z 表示对象在屏幕/查看器附近，而负值 z 表示该对象不在屏幕上。同样，x 的正值表示对象是屏幕右侧，负值表示对象是左侧。同样，y 的正值和负值表示对象位于屏幕顶部或底部的底部。</p><img src="/2017/webgl-draw-rectangle-and-point/coordinate.png"><h4 id="顶点与片元着色器介绍"><a href="#顶点与片元着色器介绍" class="headerlink" title="顶点与片元着色器介绍"></a>顶点与片元着色器介绍</h4><ul><li>顶点你着色器是用来描述顶点特征（如位置、颜色等）的程序。<em>顶点</em> 是指二维或三维空间中的一个点，将这些顶点连接起来，可以形成线或三角形，WebGL 中最常用的是三角形。</li><li>片元着色器是进行逐片元处理过程的程序，如处理光照，片元史 WebGL 术语，可以理解为像素。</li></ul><h4 id="创建着色器步骤"><a href="#创建着色器步骤" class="headerlink" title="创建着色器步骤"></a>创建着色器步骤</h4><p>(一)、使用 <code>gl.createProgram()</code> 方法用于创建和初始化一个 <code>WebGLProgram</code> 对象。<br>(二)、使用 <code>gl.createShader(type)</code> 创建一个 <code>WebGLShader</code> 着色器对象。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>type</td><td>gl.VERTEX_SHADER 为顶点着色器，gl.FRAGMENT_SHADER 为片元着色器</td></tr></tbody></table><p>(三)、使用 <code>gl.shaderSource(shader, source)</code> 挂接 <code>source</code> (GLSL) 源代码到 <code>shader</code> 上。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>shader</td><td>包含顶点着色器和片元着色器的 <code>WebGLShader</code> 对象</td></tr><tr><td>source</td><td>一坨字符串，也就是着色器 (GLSL) 语言代码</td></tr></tbody></table><p>(四)、使用 <code>gl.compileShader(shader)</code> 编译一个 GLSL 着色器，使其成为为二进制数据，然后就可以被 <code>WebGLProgram</code> 对象所使用。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>shader</td><td>一个片元或顶点着色器</td></tr></tbody></table><p>(五)、使用 <code>gl.attachShader(program, shader)</code> 方法把着色器 <code>shader</code> 添加到 <code>program</code>。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>program</td><td>包含顶点着色器和片元着色器的 <code>WebGLProgram</code> 对象</td></tr><tr><td>shader</td><td>一个类型为片段或者顶点的 <code>WebGLShader</code> 对象</td></tr></tbody></table><p>(六)、使用 <code>gl.linkProgram(program)</code> 和 <code>gl.useProgram(program)</code> 分别链接和使用 <code>WebGLProgram</code> 对象。</p><p>综上六个步骤就可以创建一个顶点着色器或片元着色器，为了方便这里把创建着色器封装成了一个 <code>createShader(type, source)</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  createShader(type, source) &#123;</div><div class="line">    <span class="comment">// 创建一个`WebGLShader`着色器对象，`type`为`gl.VERTEX_SHADER`(顶点着色器)或`gl.FRAGMENT_SHADER`片元着色器</span></div><div class="line">    <span class="keyword">const</span> shader = <span class="keyword">this</span>.gl.createShader(type);</div><div class="line"></div><div class="line">    <span class="comment">// 挂接`source`(GLSL)源代码到`shader`上</span></div><div class="line">    <span class="keyword">this</span>.gl.shaderSource(shader, source);</div><div class="line"></div><div class="line">    <span class="comment">// 编译`shader`(GLSL)为二进制文件，以便被`WebGLProgram`使用</span></div><div class="line">    <span class="keyword">this</span>.gl.compileShader(shader);</div><div class="line"></div><div class="line">    <span class="comment">// 添加一个片元着色器或者顶点着色器</span></div><div class="line">    <span class="keyword">this</span>.gl.attachShader(<span class="keyword">this</span>.shaderProgram, shader);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> shader;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="初始化顶点和片元着色器"><a href="#初始化顶点和片元着色器" class="headerlink" title="初始化顶点和片元着色器"></a>初始化顶点和片元着色器</h4><p>接下来在添加一个 <code>constructor()</code> 和 <code>initShader()</code> 方法，用来获取 <code>WebGLRenderingContext</code> 对象和初始化顶点着色器和片元着色器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.gl = self.gl = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">    <span class="keyword">this</span>.gl.viewport(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.gl.drawingBufferWidth, <span class="keyword">this</span>.gl.drawingBufferHeight);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  initShader() &#123;</div><div class="line">    <span class="comment">// 创建一个`WebGLProgram`</span></div><div class="line">    <span class="keyword">this</span>.shaderProgram = <span class="keyword">this</span>.gl.createProgram();</div><div class="line"></div><div class="line">    <span class="comment">// 创建顶点着色器</span></div><div class="line">    <span class="keyword">this</span>.createShader(<span class="keyword">this</span>.gl.VERTEX_SHADER, <span class="string">`</span></div><div class="line"><span class="string">      attribute vec4 a_Position;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">      void main() &#123;</span></div><div class="line"><span class="string">        gl_Position = a_Position;</span></div><div class="line"><span class="string">        gl_PointSize = 10.0;</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建片元着色器</span></div><div class="line">    <span class="keyword">this</span>.createShader(<span class="keyword">this</span>.gl.FRAGMENT_SHADER, <span class="string">`</span></div><div class="line"><span class="string">      void main() &#123;</span></div><div class="line"><span class="string">        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 分别链接和使用</span></div><div class="line">    <span class="keyword">this</span>.gl.linkProgram(<span class="keyword">this</span>.shaderProgram);</div><div class="line">    <span class="keyword">this</span>.gl.useProgram(<span class="keyword">this</span>.shaderProgram);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上边程序中第 16-21 行编写了顶点着色器，26-28 行编写了片元着色器，从这两块的程序中可以看出，GLSL 语言是跟 C 语言非常类似的，都必须包含一个 <code>main()</code> 函数，<code>main()</code> 前边的关键字 <code>void</code> 是表示这个函数不会有返回值，还有不能为 <code>main()</code> 函数指定参数。</p><p>在顶点着色器和中使用了：<code>gl_Position</code>、<code>gl_Position</code> 和片元着色器中的： <code>gl_FragColor</code>，这些分别为内置的变量，我们把相应的值赋值给相应的内置变量就可以得到相应的渲染结果，它们的功能如下：</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>gl_Position</td><td>表示顶点位置</td></tr><tr><td>gl_Position</td><td>表示点的尺寸</td></tr><tr><td>gl_FragColor</td><td>指定片元颜色（RGBA）</td></tr></tbody></table><p>并且 GLSL 语言为强类型语言，如果把第 20 行的 <code>gl_PointSize = 10.0</code> 改为 <code>gl_PointSize = 10</code> 就会导致程序报错，上边使用到的类型介绍如下：</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>float</td><td>表示浮点数</td></tr><tr><td>vec4</td><td>表示由四个浮点数组成的矢量，另外三种：vec1、vec2、vec3</td></tr></tbody></table><p>其中 <code>vec4</code> 在这里有两种身份，它既能声明变量类型： <code>attribute vec4 a_Position</code>，又能作为 <em>构造函数</em> (Constructor Functions) 使用：<code>gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)</code>，构造函数的名称和创建的变量的名称是一致的。最前边的关键 <code>attribute</code> 被称为 <em>储存限定符</em> (Storage Qualifier)，<code>attribute</code> 必须声明为全局变量，数据将从着色器外部传给该变量。</p><p>着色器初始化完成后就可以开始画点了，步骤如下：</p><p>(一)、使用 <code>gl.getAttribLocation(program, name)</code> 方法获取 <code>attribute</code> 变量的储存位置。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>program</td><td>包含顶点着色器和片元着色器的 <code>WebGLProgram</code> 对象</td></tr><tr><td>name</td><td>着色器 <code>attribute</code> 变量的名称</td></tr></tbody></table><p>(二)、使用 <code>gl.vertexAttrib3f(index, v0, v1, v2)</code> 方法向 <code>attribute</code> 变量赋值。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>index</td><td><code>attribute</code> 的储存位置</td></tr><tr><td>v0</td><td>指定填充 <code>attribute</code> 变量第一个分量的值</td></tr><tr><td>v1</td><td>指定填充 <code>attribute</code> 变量第二个分量的值</td></tr><tr><td>v2</td><td>指定填充 <code>attribute</code> 变量第三个分量的值</td></tr></tbody></table><p>(三)、使用 <code>gl.drawArrays(mode, first, count)</code> 方法进行绘制。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>mode</td><td>绘制的方式，可以选择的常量：gl.POINTS、gl.LINES、gl.LINE_STRIP、gl.LINE_LOOP、gl.TRIANGLES、gl.TRIANGLE_STRIP、gl.TRIANGLE_FAN</td></tr><tr><td>first</td><td>指定从哪个顶点开始绘制</td></tr><tr><td>count</td><td>指定绘制需要多少个顶点</td></tr></tbody></table><p><code>mode</code> 可以绘制的基本图形解析：</p><table><thead><tr><th>mode</th><th>图形</th><th>表述</th></tr></thead><tbody><tr><td>gl.POINTS</td><td>点</td><td>一系列点，绘制在 v0、v1、v2 … 处</td></tr><tr><td>gl.LINES</td><td>线段</td><td>一系列单独的线段，绘制在 (v0, v1)、(v2, v3)、(v4, v5) … 处，如果点的个数是奇数，最后一个点将被忽略</td></tr><tr><td>gl.LINE_STRIP</td><td>线条</td><td>一系列连接的线段,被绘制在(v0,v1)、(v1,v2)、(v2,v3) … 处，第 1 个点是第1条线段的起点，第 2 个点是第 1 条线段的终点和第 2 条线段的起点 … 第 i(i&gt;1) 个点是第 i-1 条线段的终点和第 i 条线段的起点，以此类推。最后一个点是最后一条线段的终点</td></tr><tr><td>gl.LINE_LOOP</td><td>回路</td><td>一系列连接的线段。与gl.LINE_STRIP 绘制的线条相比，增加了一条从最后一个点到第1个点的线段。因此，线段被绘制在 (v0, v1)、(v1, v2) … (vn, v0) 处，其中 vn 是最后一个点</td></tr><tr><td>gl.TRIANGLES</td><td>三角形</td><td>一系列单独的三角形，绘制在 (v0, v1, v2)、(v3, v4, v5) … 处，如果点的个数不是 3 的整数倍，最后剩下的一或两个点将被忽略</td></tr><tr><td>gl.TRIANGLE_STRIP</td><td>三角带</td><td>一系列条带状的三角形，前三个点构成了第 1 个三角形，从第 2 个点开始的三个点构成了第 2 个三角形(该三角形与前一个三角形共享一条边)，以此类推。这些三角形被绘制在 (v0, v1, v2)、(v2, v1, v3)(v2, v3, v4) … 处</td></tr><tr><td>gl.TRIANGLE_FAN</td><td>三角扇</td><td>一系列三角形组成的类似于扇形的图形。前三个点构成了第 1 个三角形，接下来的一个点和前一个三角形的最后一条边组成接下来的一个三角形。这些三角形被绘制在 (v0, v1, v2)、(v0, v2, v3)、(v0, v3, v4) … 处</td></tr></tbody></table><h4 id="绘制三维世界中的点"><a href="#绘制三维世界中的点" class="headerlink" title="绘制三维世界中的点"></a>绘制三维世界中的点</h4><p>添加一个 <code>drawPoint()</code> 方法进行画点，在运行前我们在 <code>constructor()</code> 方法中分别调用 <code>this.initShader()</code> 和 <code>this.drawPoint()</code> 方法，最终代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.initShader();</div><div class="line">    <span class="keyword">this</span>.drawPoint();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  drawPoint() &#123;</div><div class="line">    <span class="keyword">const</span> a_Position = <span class="keyword">this</span>.gl.getAttribLocation(<span class="keyword">this</span>.shaderProgram, <span class="string">'a_Position'</span>);</div><div class="line">    <span class="keyword">this</span>.gl.vertexAttrib4f(a_Position, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">    <span class="keyword">this</span>.gl.drawArrays(<span class="keyword">this</span>.gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>预览效果 <a href="https://stackblitz.com/edit/webgl-draw-point" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-point@2x.png" width="316" height="322"><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>本文中出现了一些 WebGL 的一些概念，对于初学者来说，你不需要记住本文中的所有东西，在后续的教程中将一步步深入研究这些概念，再加上经常练习才能真正理解，所以，现在还不用太严肃，现在只需要享受阅读，等以后再回头看也不迟。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Canvas-简介&quot;&gt;&lt;a href=&quot;#Canvas-简介&quot; class=&quot;headerlink&quot; title=&quot;Canvas 简介&quot;&gt;&lt;/a&gt;Canvas 简介&lt;/h3&gt;&lt;p&gt;在 HTML5 出现之前，如果想要在网页上显示图像，只能使用 HTML 提供的 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。用这个标签虽然简单，但是只能显示静态的图片，不能进行实时绘制和渲染，所以后来出现了一些第三方的解决方案，比如 Flash Player 等。&lt;/p&gt;&lt;p&gt;Canvas 中文译为“画布”，作为画布我们可以使用 &lt;code&gt;HTMLCanvasElement.getContext(contextType)&lt;/code&gt; 获取 Canvas 的上下文，然后使用上下文提供的 API 在画布区域绘制图案，接下来分别介绍怎么使用二维和三维的方法绘制矩形和点。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://sanonz.github.io/categories/front-end/"/>
    
    
      <category term="JavaScript" scheme="https://sanonz.github.io/tags/JavaScript/"/>
    
      <category term="3D" scheme="https://sanonz.github.io/tags/3D/"/>
    
      <category term="WebGL" scheme="https://sanonz.github.io/tags/WebGL/"/>
    
      <category term="Canvas" scheme="https://sanonz.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>WebGL 三维教程 - WebGL 介绍（一）</title>
    <link href="https://sanonz.github.io/2017/webgl-introduction/"/>
    <id>https://sanonz.github.io/2017/webgl-introduction/</id>
    <published>2017-10-24T12:25:23.000Z</published>
    <updated>2017-11-13T02:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WebGL-概述"><a href="#WebGL-概述" class="headerlink" title="WebGL 概述"></a>WebGL 概述</h3><p>WebGL 是一项在网页上绘制和渲染复杂三维图形（3D 图形），并允许用户与之进行交互的技术，在传统上只有高配置的计算机或专用的游戏机才能渲染三维图形，而现在随着个人计算机与浏览器的性能越来越强，使用便捷通用的 Web 技术创建和渲染三维图形已经成为可能。HTML5 作为目前最新的 HTML 标准，扩展了传统 HTML 的特征，如二维图形、网络传输、本地数据储存等，HTML5 时代的到来使浏览器正在迅速地从简单的展示工具转变为复杂的应用平台，人们希望网页不仅仅由二维图组成，所以 WebGL就顺着时代的召唤到来了。</p><h3 id="WebGL-的起源"><a href="#WebGL-的起源" class="headerlink" title="WebGL 的起源"></a>WebGL 的起源</h3><p>在个人计算机上使用最广泛的两种三维图形渲染技术使 Direct3D 和 OpenGL。Direct3D 是微软DirectX 技术的一部分，是一套由微软控制的编程接口（API），主要用在 Windows 平台；而 OpenGL 由于其开放和免费的特征，在多种平台上都有广泛地使用，后来 Windows 对 OpenGL 也提供了良好的支撑，开发者也可以使用它来代替 Direct3D。</p><a id="more"></a><p>OpenGL 最初是由 SGI（Silicon Graphics Inc）开发，并在 1992 年发布为开源标准。多年以来，OpenGL 发展了数个版本，并对三维图形开发、软件产品开发、甚至电影制作产生了深远的影响。虽然 WebGL 根植于 OpenGL，但它实际上是从 OpenGL 的一个特殊版本 OpenGL ES 派生出来的，OpenGL ES 主要专用于嵌入式计算机、智能手机、家用用洗等设备。OpenGL ES 于 2003～2004 年被首次提出，并在 2007 年（ES 2.0）进行了两次升级，WebGL 是基于 OpenGL ES 2.0 的。这几年采用 OpenGL ES 技术的电子设备的数量大幅度增长，尤其是移动端设备。OpenGL ES 成功被这些设备采用的部分原因是，它在添加新特性的同时从 OpenGL 中移除了许多陈旧的旧特性，这使它在保持轻量级的同时，仍具有足够的能力来渲染出精美的三维图形。</p><h3 id="WebGL-的优势"><a href="#WebGL-的优势" class="headerlink" title="WebGL 的优势"></a>WebGL 的优势</h3><p>这些年随着 HTML 的发展，网页由最初简单的静态页面变得越来越复杂，从引入 JavaScript 等脚本语言，HTML 开始提供一些动态的内容，并具有一定的交互性。现在出现了更强大的 HTML5，它可以使用 canvas 或 svg 标签在网页上绘制二维图形，以呈现更丰富的内容如：在线的在线作图 <a href="https://processon.com/" target="_blank" rel="noopener">ProcessOn</a>、原型设计 <a href="https://modao.cc/" target="_blank" rel="noopener">墨刀</a> 以及提供一整套的在线办公软件的 <a href="https://www.zoho.com/" target="_blank" rel="noopener">Zohu</a> 等工具。</p><p>WebGL 则走的更远，它允许 JavaScript 在网页上显示和操作三维图形。有了 WebGL 技术，开发三维的客户端界面、运行三维的网页游戏，对互联网上的海量数据进行三维可视化都成了可能，无需考虑平台问题、无需繁琐的安装过程、无需经堂备份自己的文件到云端来实现共享。虽然 WebGL 强大到令人惊叹，但使用这项技术进行开发却异常简单，让我们一步步探索吧。</p><h3 id="WebGL-程序结构"><a href="#WebGL-程序结构" class="headerlink" title="WebGL 程序结构"></a>WebGL 程序结构</h3><p>在写 WebGL 页面时需要三种语言：HTML5／（CSS）、JavaScript和 GLSL ES（着色器语言），因为通常 GLSL ES 是以字符串的形式在 JavaScript 中编写的，实际上在写 WebGL 页面时结构还是和平常一样。所以，虽然 WebGL 页面更加复杂了一些，但是仍然保持着和传统页面一样的风格。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;WebGL-概述&quot;&gt;&lt;a href=&quot;#WebGL-概述&quot; class=&quot;headerlink&quot; title=&quot;WebGL 概述&quot;&gt;&lt;/a&gt;WebGL 概述&lt;/h3&gt;&lt;p&gt;WebGL 是一项在网页上绘制和渲染复杂三维图形（3D 图形），并允许用户与之进行交互的技术，在传统上只有高配置的计算机或专用的游戏机才能渲染三维图形，而现在随着个人计算机与浏览器的性能越来越强，使用便捷通用的 Web 技术创建和渲染三维图形已经成为可能。HTML5 作为目前最新的 HTML 标准，扩展了传统 HTML 的特征，如二维图形、网络传输、本地数据储存等，HTML5 时代的到来使浏览器正在迅速地从简单的展示工具转变为复杂的应用平台，人们希望网页不仅仅由二维图组成，所以 WebGL就顺着时代的召唤到来了。&lt;/p&gt;&lt;h3 id=&quot;WebGL-的起源&quot;&gt;&lt;a href=&quot;#WebGL-的起源&quot; class=&quot;headerlink&quot; title=&quot;WebGL 的起源&quot;&gt;&lt;/a&gt;WebGL 的起源&lt;/h3&gt;&lt;p&gt;在个人计算机上使用最广泛的两种三维图形渲染技术使 Direct3D 和 OpenGL。Direct3D 是微软DirectX 技术的一部分，是一套由微软控制的编程接口（API），主要用在 Windows 平台；而 OpenGL 由于其开放和免费的特征，在多种平台上都有广泛地使用，后来 Windows 对 OpenGL 也提供了良好的支撑，开发者也可以使用它来代替 Direct3D。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://sanonz.github.io/categories/front-end/"/>
    
    
      <category term="JavaScript" scheme="https://sanonz.github.io/tags/JavaScript/"/>
    
      <category term="3D" scheme="https://sanonz.github.io/tags/3D/"/>
    
      <category term="WebGL" scheme="https://sanonz.github.io/tags/WebGL/"/>
    
      <category term="Canvas" scheme="https://sanonz.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 搭建静态博客与 hexo-theme-concise 主题使用教程</title>
    <link href="https://sanonz.github.io/2017/hello-world/"/>
    <id>https://sanonz.github.io/2017/hello-world/</id>
    <published>2017-10-20T15:01:31.000Z</published>
    <updated>2017-11-28T01:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一款基于Node.js的一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，你可以把生成的静态网页上传到 Web 服务器上，这里我们选用的是 GitHub 做 Web 服务器，你没看错，全球最大的同性恋交友网站（🙈逃……），然后就可以访问到博客站点，因为每个页面都是静态的，所以访问速度是非常快的，用户体验非常好。</p><h3 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h3><p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown</a> 是一种用来写作的轻量级「标记语言」，后缀格式通常为：.md 或 .markdown，用简洁的语法来描述排版格式，可以让我们更专心的写作，因为 Markdown 是纯文本格式，所以可以实现跨平台，不管你切换到什么设备都可以查阅及写作，并且可以轻松的转换为HTML、PDF、电子书等。目前市场上还有大量在线编辑器，支持实时预览，让你充分享受 Markdown 带来的愉悦感。</p><a id="more"></a><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Nodejs</a></li></ul><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> # 设置 npm 为国内镜像提升安装速度，如果你已经设置过了请忽略</div><div class="line"><span class="meta">$</span> npm config set registry https://registry.taobao.org/</div><div class="line"><span class="meta">$</span></div><div class="line"><span class="meta">$</span> # 安装 Hexo</div><div class="line"><span class="meta">$</span> npm install -g hexo-cli</div></pre></td></tr></table></figure><p>安装完成后执行以下命令新建一个站点<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> # 新建站点</div><div class="line"><span class="meta">$</span> hexo init blog-markdown</div><div class="line"><span class="meta">$</span></div><div class="line"><span class="meta">$</span> # 切换到站点下</div><div class="line"><span class="meta">$</span> cd blog-markdown</div><div class="line"><span class="meta">$</span></div><div class="line"><span class="meta">$</span> # 添加一篇文章</div><div class="line"><span class="meta">$</span> hexo new welcome</div></pre></td></tr></table></figure><p></p><p>文章默认会被添加到 ./source/_posts 目录下，进入到此目录然后使用心意的编辑器打开 welcome.md 文件<br></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: welcome</div><div class="line">date: 2017-10-20 23:01:31</div><div class="line">tags:</div><div class="line">---</div></pre></td></tr></table></figure><p></p><!-- more --><p>编辑为<br></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: 我发布的第一篇文章</div><div class="line">date: 2017-10-20 23:01:31</div><div class="line">tags:</div><div class="line"><span class="bullet">- </span>生活</div><div class="line"><span class="bullet">- </span>诗和远方</div><div class="line">---</div><div class="line"></div><div class="line"></div><div class="line">人生不只眼前的苟且，还有诗和远方。</div></pre></td></tr></table></figure><p></p><p>生成静态文件<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> # 可以使用简写方式：hexo g</div><div class="line"><span class="meta">$</span> hexo generate</div></pre></td></tr></table></figure><p></p><p>执行一下命令，在浏览器中打开：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 进行预览<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> # 简写：hexo s</div><div class="line"><span class="meta">$</span> hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p></p><h3 id="登陆到-GitHub"><a href="#登陆到-GitHub" class="headerlink" title="登陆到 GitHub"></a>登陆到 GitHub</h3><p>登陆地址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>，没有账号注册一个，登陆成功之后点击顶部导航条的➕号，并选择 <a href="https://github.com/new" target="_blank" rel="noopener"><code>New repository</code></a>，如下图</p><img src="/2017/hello-world/github-create@2x.png"><p>填写 Repository name 一项，比如填写 <code>sanonz</code> 然后就可以通过：<a href="https://sanonz.github.io">https://sanonz.github.io</a> 来访问（访问之前根目录要有默认的 index.html 才能正常打开），填写完成后点击 Create repository 按钮提交创建，如下图</p><img src="/2017/hello-world/github-create-repository@2x.png"><p>提交成功后复制红色框住的仓库地址</p><img src="/2017/hello-world/github-created@2x.png"><h3 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h3><p>修改 _config.yml 中的参数<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span></div></pre></td></tr></table></figure><p></p><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure><p></p><p>修改 _config.yml 配置，把刚刚复制的仓库地址粘贴到 repo: 后边<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span></div><div class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/Sanonz/your-blog.github.io.git</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">master</span></div><div class="line">  <span class="comment"># message: [message]</span></div></pre></td></tr></table></figure><p></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>repo</td><td>库（Repository）地址</td></tr><tr><td>branch</td><td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td></tr><tr><td>message</td><td>自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} )</td></tr></tbody></table><p>Hexo 一键部署到 GitHub<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo deploy</div></pre></td></tr></table></figure><p></p><p>部署成功后查看站点：<a href="https://your-blog.github.io" target="_blank" rel="noopener">https://your-blog.github.io</a></p><h3 id="使用-hexo-theme-concise-主题"><a href="#使用-hexo-theme-concise-主题" class="headerlink" title="使用 hexo-theme-concise 主题"></a>使用 hexo-theme-concise 主题</h3><p><a href="https://github.com/Sanonz/hexo-theme-concise" target="_blank" rel="noopener">Concise</a> 主题为博主开发的简约主题，也就是本站所用的主题，如果您喜欢的话可以按以下教程切换为本站所使用的主题<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git clone https://github.com/Sanonz/hexo-theme-concise themes/concise</div></pre></td></tr></table></figure><p></p><p>修改 _config.yml 配置<br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">theme:</span> <span class="string">concise</span></div></pre></td></tr></table></figure><p></p><p>因为这个主题使用了 less 编译，Hexo 默认的编译器为 <a href="https://github.com/hexojs/hexo-renderer-stylus" target="_blank" rel="noopener">hexo-renderer-stylus</a> 要切换为 <a href="https://github.com/hexojs/hexo-renderer-less" target="_blank" rel="noopener">hexo-renderer-less</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-renderer-less --save</div></pre></td></tr></table></figure><p></p><p>如果你不需要 <code>hexo-renderer-stylus</code> 可以把它卸载掉<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm uninstall hexo-renderer-stylus --save</div></pre></td></tr></table></figure><p></p><p>清除缓存数据<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></div><div class="line"><span class="meta">$</span><span class="bash"> hexo server</span></div></pre></td></tr></table></figure><p></p><p>刷新页面查看新主题效果，Concise 主题的具体配置到 <a href="https://github.com/Sanonz/hexo-theme-concise/blob/master/README.md" target="_blank" rel="noopener">这里查看</a>，如果在使用过程遇到问题欢迎提 <a href="https://github.com/Sanonz/hexo-theme-concise/issues" target="_blank" rel="noopener">Issues</a>，最后如果喜欢的话给个 Star 😍</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h3&gt;&lt;p&gt;Hexo 是一款基于Node.js的一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，你可以把生成的静态网页上传到 Web 服务器上，这里我们选用的是 GitHub 做 Web 服务器，你没看错，全球最大的同性恋交友网站（🙈逃……），然后就可以访问到博客站点，因为每个页面都是静态的，所以访问速度是非常快的，用户体验非常好。&lt;/p&gt;&lt;h3 id=&quot;什么是-Markdown&quot;&gt;&lt;a href=&quot;#什么是-Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是 Markdown&quot;&gt;&lt;/a&gt;什么是 Markdown&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt; 是一种用来写作的轻量级「标记语言」，后缀格式通常为：.md 或 .markdown，用简洁的语法来描述排版格式，可以让我们更专心的写作，因为 Markdown 是纯文本格式，所以可以实现跨平台，不管你切换到什么设备都可以查阅及写作，并且可以轻松的转换为HTML、PDF、电子书等。目前市场上还有大量在线编辑器，支持实时预览，让你充分享受 Markdown 带来的愉悦感。&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="https://sanonz.github.io/categories/front-end/"/>
    
    
      <category term="Hexo" scheme="https://sanonz.github.io/tags/Hexo/"/>
    
      <category term="Nodejs" scheme="https://sanonz.github.io/tags/Nodejs/"/>
    
      <category term="JavaScript" scheme="https://sanonz.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
